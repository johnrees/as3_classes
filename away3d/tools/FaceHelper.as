package away3d.tools{	import away3d.arcane;	import away3d.core.base.Geometry;	import away3d.core.base.SubGeometry;	import away3d.core.base.data.Vertex;	import away3d.core.base.data.UV;	import away3d.core.base.data.Face;	import away3d.loading.IResource;	import away3d.loading.ResourceDependency;	import away3d.entities.Mesh;	import away3d.containers.ObjectContainer3D;		import away3d.tools.MeshHelper;		use namespace arcane;		/**	* Helper Class for face manipulation<code>FaceHelper</code>	* 	*/	 	public class FaceHelper {				private static const LIMIT:uint = 64998;		 		public static function addFace(mesh:Mesh, v0:Vertex, v1:Vertex, v2:Vertex, uv0:UV, uv1:UV, uv2:UV, subGeomIndice:uint):void		{			var subGeom:SubGeometry = mesh.geometry.subGeometries[subGeomIndice];			var vertices:Vector.<Number> = subGeom.vertexData;			var indices:Vector.<uint>;			var uvs:Vector.<Number>;			var normals:Vector.<Number>;			var tangents:Vector.<Number>;			var lengthVertices:uint = vertices.length;			if(lengthVertices+9>LIMIT){				indices = Vector.<Number>([0,1,2]);				vertices = Vector.<uint>([v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z]);				uvs = Vector.<Number>([uv0.u, uv0.v, uv1.u, uv1.v, uv2.u, uv2.v]);				//to do				normals = Vector.<Number>([0, 0, 1, 0, 0, 1]);				tangents = Vector.<Number>([0, 0, -1, 0, 0, -1]);				//				subGeom = new SubGeometry();				mesh.geometry.addSubGeometry(subGeom);			} else{				indices = subGeom.indexData;				uvs = subGeom.UVData;				normals = subGeom.vertexNormalData;				tangents = subGeom.vertexTangentData;				vertices.fixed = indices.fixed = uvs.fixed = normals.fixed = tangents.fixed = false;				var ind:uint = lengthVertices/3;				var nind:uint = indices.length;				indices[nind++] = ind++;				indices[nind++] = ind++;				indices[nind++] = ind++;				vertices.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);				uvs.push(uv0.u, uv0.v, uv1.u, uv1.v, uv2.u, uv2.v);			}						subGeom.updateVertexData(vertices);			subGeom.updateIndexData(indices);			subGeom.updateUVData(uvs);			subGeom.updateIndexData(indices);			subGeom.updateUVData(uvs);		}				/**		* Remove a face from a mesh		* @param mesh						Mesh. The mesh to remove a face from		* @param index						uint. Index of the face in vertices. The x value of face v0.		* @param subGeomIndice		uint. Index of vertex 1 of the face		*/				//todo return the remove Face as face to ease some manipulations		public static function removeFace(mesh:Mesh, index:uint, subGeomIndice:uint):void		{			var pointer:uint = index*3;			var subGeoms:Vector.<SubGeometry> = mesh.geometry.subGeometries;						if(subGeomIndice>subGeoms.length-1)				throw new Error("ERROR >> subGeomIndice is incorrect!");						var subGeom:SubGeometry = subGeoms[subGeomIndice];			var vertices:Vector.<Number> = subGeom.vertexData;			var indices:Vector.<uint> = subGeom.indexData;			 			if(pointer > (vertices.length/3)-1)				throw new Error("ERROR >> face index out of range!");						var uvs:Vector.<Number> = subGeom.UVData;			var normals:Vector.<Number> = subGeom.vertexNormalData;			var tangents:Vector.<Number> = subGeom.vertexTangentData;			 			var pointerEnd:uint = pointer+2;			subGeom.dispose();			  			var oInd:uint;			var oVInd:uint;			var oUVInd:uint;						var indInd:uint;			var uvInd:uint;			var vInd:uint;						var i:uint;			var j:uint;						var nvertices:Vector.<Number> = new Vector.<Number>();			var nindices:Vector.<uint> = new Vector.<uint>();			var nuvs:Vector.<Number> = new Vector.<Number>();			var nnormals:Vector.<Number> = new Vector.<Number>();			var ntangents:Vector.<Number> = new Vector.<Number>();			 			//Check for shared vectors			if(vertices.length/3 != indices.length){				var sharedIndice:int;								for(i = 0; i<indices.length;++i){										if(i >= pointer && i <= pointerEnd)						continue;										oInd = indices[i];					oVInd = oInd*3;					oUVInd = oInd*2;					 					//TODO: from this point faces gets welded,					// need add a check on "till this pointer was this original indice[i] shared or not, then consider as unique if not					//even if it could be shared...										sharedIndice = getUsedIndice(nvertices, vertices[oVInd], vertices[oVInd+1], vertices[oVInd+2]);										if(sharedIndice != -1){						nindices[indInd++] = sharedIndice;						continue;					}											nindices[indInd++] = nvertices.length/3;										nvertices[vInd] = vertices[oVInd];					nnormals[vInd] = normals[oVInd];					ntangents[vInd] = tangents[oVInd];					vInd++;										oVInd++;					nvertices[vInd] = vertices[oVInd];					nnormals[vInd] = normals[oVInd];					ntangents[vInd] = tangents[oVInd];					vInd++;										oVInd++;					nvertices[vInd] = vertices[oVInd];					nnormals[vInd] = normals[oVInd];					ntangents[vInd] = tangents[oVInd];					vInd++;										nuvs[uvInd++] = uvs[oUVInd];					nuvs[uvInd++] = uvs[oUVInd+1];				}				 			} else {				for(i = 0; i<indices.length;++i){										if(i < pointer || i > pointerEnd){						oInd = indices[i];						oVInd = oInd*3;						oUVInd = oInd*2;												nindices[indInd++] = vInd/3;						 						nvertices[vInd] = vertices[oVInd];						nnormals[vInd] = normals[oVInd];						ntangents[vInd] = tangents[oVInd];						vInd++;												oVInd++;						nvertices[vInd] = vertices[oVInd];						nnormals[vInd] = normals[oVInd];						ntangents[vInd] = tangents[oVInd];						vInd++;												oVInd++;						nvertices[vInd] = vertices[oVInd];						nnormals[vInd] = normals[oVInd];						ntangents[vInd] = tangents[oVInd];						vInd++;						 						nuvs[uvInd++] = uvs[oUVInd];						nuvs[uvInd++] = uvs[oUVInd+1];						 					} 				}			}						subGeom.updateVertexData(nvertices);			subGeom.updateIndexData(nindices);			subGeom.updateUVData(nuvs);			subGeom.updateVertexNormalData(nnormals);			subGeom.updateVertexTangentData(ntangents); 			 		}				/**		* Remove a series of faces from a mesh. Indices and geomIndices must have the same length.		* Meshes with less that 20k faces and single material, will generally only have one single subgeometry.		* The geomIndices vector will then contain only zeros.		* IMPORTANT: the code considers the indices as location in the mesh subgemeometry indices vector, not the value at the pointer location.		* 		* @param mesh										Mesh. The mesh to remove a face from		* @param indices									Vector.<uint>. A vector with a series of uints indices: the indices of the faces to be removed. 		* @param subGeomIndices						Vector.<uint>. A vector with a series of uints indices representing the subgeometries of the faces to be removed.		*/		public static function removeFaces(mesh:Mesh, indices:Vector.<uint>, subGeomIndices:Vector.<uint>):void		{			for(var i:uint = 0; i<indices.length;++i)				removeFace(mesh, indices[i], subGeomIndices[i]);						//todo meshhelper, reaarange geometries in case of empty subgeoms			/*if(mesh.geometry.geometries.length > 1)				MeshHelper.reArrangeGeometries();*/		}				/**		* Adds a series of faces from a mesh. All vectors must have the same length.		* @param mesh						Mesh. The mesh to remove a face from		* @param v0s						Vector.<Vertex>. A vector with a series of Vertex Objects representing the v0 of a face. 		* @param v1s						Vector.<Vertex>. A vector with a series of Vertex Objects representing the v1 of a face. 		* @param v2s						Vector.<Vertex>. A vector with a series of Vertex Objects representing the v2 of a face. 		* @param uv0s						Vector.<UV>. A vector with a series of UV Objects representing the uv0 of a face.		* @param uv1s						Vector.<UV>. A vector with a series of UV Objects representing the uv1 of a face. 		* @param uv2s						Vector.<UV>. A vector with a series of UV Objects representing the uv2 of a face. 		*/		public static function addFaces(mesh:Mesh, v0s:Vector.<Vertex>, v1s:Vector.<Vertex>, v2s:Vector.<Vertex>, uv0s:Vector.<UV>, uv1s:Vector.<UV>, uv2s:Vector.<UV>, subGeomIndices:Vector.<uint>):void		{			for(var i:uint = 0; i<v0s.length;++i)				addFace(mesh, v0s[i], v1s[i], v2s[i], uv0s[i], uv1s[i], uv2s[i], subGeomIndices[i]);			 		}				private static function getUsedIndice(vertices:Vector.<Number>, x:Number, y:Number, z:Number):int		{			for(var i:uint = 0; i<vertices.length;i+=3){				if(vertices[i] == x && vertices[i+1] == y && vertices[i+1] == z)					return i/3;			}			return -1;		}	}}