package away3d.tools.utils{	import flash.geom.Vector3D;		import away3d.arcane;	import away3d.core.base.Geometry;	import away3d.core.base.SubGeometry;	import away3d.entities.Mesh;	import away3d.containers.ObjectContainer3D;		use namespace arcane;		/**	* Helper Class to retrieve objects bounds <code>Bounds</code>	* 	*/	 	public class Bounds {		 		private static var _minX:Number = Infinity;		private static var _minY:Number = Infinity;		private static var _minZ:Number = Infinity;		private static var _maxX:Number = -Infinity;		private static var _maxY:Number = -Infinity;		private static var _maxZ:Number = -Infinity;		private static var _defaultPosition:Vector3D = new Vector3D(0.0,0.0,0.0);				public static function get minX():Number		{			return _minX;		}		public static function get minY():Number		{			return _minY;		}		public static function get minZ():Number		{			return _minZ;		}		public static function get maxX():Number		{			return _maxX;		}		public static function get maxY():Number		{			return _maxY;		}		public static function get maxZ():Number		{			return _maxZ;		}				public static function get width():Number		{			return _maxX - _minX;		}		public static function get height():Number		{			return _maxY - _minY;		}		public static function get depth():Number		{			return _maxZ - _minZ;		}		 		public static function getMeshBounds(m:Mesh, reset:Boolean = true, position:Vector3D = null):void		{			var geometries:Vector.<SubGeometry> = m.geometry.subGeometries;			var numSubGeoms:int = geometries.length;						var subGeom:SubGeometry;						if(reset){				_minX = _minY = _minZ = Infinity;				_maxX = _maxY = _maxZ = -Infinity;			}						var vertices:Vector.<Number>;						var offsetPosition:Vector3D = position || _defaultPosition;						var x:Number;			var y:Number;			var z:Number;						var j : uint;			var vecLength : uint;						for (var i : uint = 0; i < numSubGeoms; ++i){				subGeom = geometries[i];				vertices = subGeom.vertexData;				vecLength = vertices.length;				for (j = 0; j < vecLength; j+=3){					//not using Math.min or max to go faster					x = vertices[j]+offsetPosition.x;					y = vertices[j+1]+offsetPosition.y;					z = vertices[j+2]+offsetPosition.z;										if(x < _minX) _minX = x;					if(x > _maxX) _maxX = x;										if(y < _minY) _minY = y;					if(y > _maxY) _maxY = y;										if(z < _minZ) _minZ = z;					if(z > _maxZ) _maxZ = z;				}				 			}		}				public static function getObjectContainerBounds(obj:ObjectContainer3D):void		{			var child:ObjectContainer3D;						if(obj is Mesh && obj.numChildren == 0)				getMeshBounds(Mesh(obj), false, obj.position);				 			for(var i:uint = 0;i<obj.numChildren;++i){				child = obj.getChildAt(i);				getObjectContainerBounds(ObjectContainer3D(child));			}			 		}			}}