package away3d.loading.parsers{	import apparat.lzma.LZMADecoder;		import away3d.arcane;	import away3d.animators.skeleton.Skeleton;	import away3d.core.base.Geometry;	import away3d.core.base.SubGeometry;	import away3d.loading.IResource;	import away3d.materials.ColorMaterial;	import away3d.entities.Mesh;	import away3d.containers.ObjectContainer3D;		import flash.geom.Matrix3D;	import flash.utils.ByteArray;	import flash.utils.Endian;	use namespace arcane;	/**	 * AWD2Parser provides a parser for the AWD data type.	 */	public class AWD2Parser extends ParserBase	{		private var _blocks : Vector.<AWDBlock>;		private var _version : Array;		private var _compression : uint;		private var _streaming : Boolean;				private var _optimized_for_accuracy : Boolean;				private var _parsed_header : Boolean;		private var _body : ByteArray;        private var _container : ObjectContainer3D;				public static const UNCOMPRESSED : uint = 0;		public static const DEFLATE : uint = 1;		public static const LZMA : uint = 2;		/**		 * Creates a new AWD2Parser object.		 * @param uri The url or id of the data or file to be parsed.		 */		public function AWD2Parser(uri : String)		{			super(uri, ParserDataFormat.BINARY);						_blocks = new Vector.<AWDBlock>;			_blocks[0] = new AWDBlock;			_blocks[0].data = null; // Zero address means null in AWD			_version = [];		}		/**		 * Indicates whether or not a given file extension is supported by the parser.		 * @param extension The file extension of a potential file to be parsed.		 * @return Whether or not the given file type is supported.		 */		public static function supportsType(extension : String) : Boolean		{			extension = extension.toLowerCase();			return extension == "awd";		}		/**		 * Tests whether a data block can be parsed by the parser.		 * @param data The data block to potentially be parsed.		 * @return Whether or not the given data is supported.		 */		public static function supportsData(data : *) : Boolean		{			var magic : String;			var bytes : ByteArray = ByteArray(data);			bytes.position = 0;			magic = data.readUTFBytes(3);			bytes.position = 0;			if (magic == 'AWD')				return true;			return false;		}		/**		 * @inheritDoc		 */		override protected function initHandle() : IResource		{			_container = new ObjectContainer3D();			return _container;		}		/**		 * @inheritDoc		 */		protected override function proceedParsing() : Boolean		{			if (!_parsed_header) {				_byteData.endian = Endian.BIG_ENDIAN;								// Parse header and decompress body				parseHeader();				switch (_compression) {					case DEFLATE:						// TODO: Decompress deflate into _body;						_body = new ByteArray;						_byteData.readBytes(_body, 0, _byteData.bytesAvailable);						_body.inflate();						_body.position = 0;						break;					case LZMA:						// TODO: Decompress LZMA into _body						var decoder : LZMADecoder;						var properties : Vector.<int>;						var out_size : int;												_body = new ByteArray;												properties = new Vector.<int>(5, true);						for(var i: int = 0; i < 5; ++i) {							properties[i] = _byteData.readUnsignedByte()						}												out_size = _byteData.readUnsignedInt();						trace('out size: ', out_size);												decoder = new LZMADecoder;						decoder.setDecoderProperties(properties);						//decoder.setDecoderProperties(Vector.<int>([0x5d, 0, 0, 0, 1]));						decoder.code(_byteData, _body, out_size);						_body.position = 0;						break;					case UNCOMPRESSED:						_body = _byteData;						break;				}								_parsed_header = true;			}						while (_body.bytesAvailable > 0 && hasTime()) {				parseNextBlock();			}						// Return complete status			if (_body.bytesAvailable==0) {				return PARSING_DONE;            }			else return MORE_TO_PARSE;		}				private function parseHeader() : void		{			var flags : uint;			var body_len : Number;						// Skip magic string and parse version			_byteData.position = 3;			_version[0] = _byteData.readUnsignedByte();			_version[1] = _byteData.readUnsignedByte();						// Parse bit flags and compression			flags = _byteData.readUnsignedShort();			_streaming 					= (flags & 0x1) == 0x1;			_optimized_for_accuracy 	= (flags & 0x2) == 0x2;						_compression = _byteData.readUnsignedByte();						trace('HEADER:');			trace('version:', _version[0], _version[1]);			trace('streaming?', _streaming);			trace('accurate?', _optimized_for_accuracy);			trace('compression:', _compression);						// Check file integrity			body_len = _byteData.readUnsignedInt();			trace('body len: ', body_len);			if (!_streaming && body_len != _byteData.bytesAvailable) {				trace('error: body len does not match file length');				// TODO: Throw error since size does not match			}		}				private function parseNextBlock() : void		{			var data : *;			var id : uint, ns : uint, type : uint, len : uint;						id = _body.readUnsignedInt();			ns = _body.readUnsignedByte();			type = _body.readUnsignedByte();			len = _body.readUnsignedInt();						trace('block:', ns, id, type, len);			switch (type) {				case 3:					//trace('Parsing mesh instance');					data = parseMeshInstance(len);					break;				case 4:					trace('Parsing mesh data');					data = parseMeshData(len);					break;				default:					//trace('Ignoring block!');					_body.position += len;					break;			}						// Store block reference for later use			_blocks[id] = new AWDBlock();			_blocks[id].data = data;			_blocks[id].id = id;		}		private function parseMeshInstance(blockLength : uint) : Mesh		{			var mesh : Mesh, geom : Geometry;			var par_id : uint, data_id : uint;			var mtx_raw : Vector.<Number>, mtx : Matrix3D;			var i : uint;						par_id = _body.readUnsignedInt();						mtx_raw = new Vector.<Number>(16, true);			for (i=0; i<16; i++) {				mtx_raw[i] = _body.readDouble();			}						trace('mtx:', mtx_raw);						data_id = _body.readUnsignedInt();			geom = _blocks[data_id].data as Geometry;						mesh = new Mesh(null, geom);			mesh.transform = new Matrix3D(mtx_raw);            _container.addChild(mesh);			return mesh;		}						private function parseMeshData(blockLength : uint) : Geometry		{			var name : String;			var geom : Geometry;			var skeleton : Skeleton;			var num_subs : uint;			var subs_parsed : uint;			var props : AWDProperties;						// Read name and sub count			name = parseVarStr();			num_subs = _body.readUnsignedShort();						// Read optional properties			props = parseProperties(); // TODO: Improve this by having some sort of key=type dictionary			skeleton = _blocks[props.get(1, 0)].data;						geom = new Geometry();						// Loop through sub meshes			subs_parsed = 0;			while (subs_parsed < num_subs) {				var i : uint, num_faces : uint;				var mat_id : uint, sm_len : uint, sm_end : uint;				var sub_geom : SubGeometry;								sub_geom = new SubGeometry;				mat_id = _body.readUnsignedInt();				sm_len = _body.readUnsignedInt();				sm_end = _body.position + sm_len;								// Loop through data streams				while (_body.position < sm_end) {					var idx : uint = 0;					var read_float : Function, read_int : Function;					var str_type : uint, str_len : uint, str_end : uint;										str_type = _body.readUnsignedByte();					str_len = _body.readUnsignedInt();					str_end = _body.position + str_len;										// Define which methods to use when reading floating					// point and integer numbers respectively. This way, 					// the optimization test and ByteArray dot-lookup					// won't have to be made every iteration in the loop.					if (_optimized_for_accuracy) {						read_float = _body.readDouble;						read_int = _body.readUnsignedInt;					}					else {						read_float = _body.readFloat;						read_int = _body.readUnsignedShort;					}																				if (str_type == 1) {						var verts : Vector.<Number> = new Vector.<Number>;						while (_body.position < str_end) {							verts[idx++] = read_float();							verts[idx++] = read_float();							verts[idx++] = read_float();						}						sub_geom.updateVertexData(verts);					}					else if (str_type == 2) {						var indices : Vector.<uint> = new Vector.<uint>;						while (_body.position < str_end) {							indices[idx++] = read_int();						}						sub_geom.updateIndexData(indices);					}					else if (str_type == 3) {						var uvs : Vector.<Number> = new Vector.<Number>;						while (_body.position < str_end) {							uvs[idx++] = read_float();						}						sub_geom.updateUVData(uvs);					}					else if (str_type == 7) {						var weights : Vector.<Number> = new Vector.<Number>;						while (_body.position < str_end) {							weights[idx++] = read_float();						}						trace('discarding weights for now, num elems =', weights.length);					}					else {						trace('unknown str type:', str_type);						_body.position = str_end;					}				}								subs_parsed++;				geom.addSubGeometry(sub_geom);			}						parseUserAttributes();						return geom;		}						private function parseVarStr() : String		{			var len : uint;						len = _body.readUnsignedShort();			return _body.readUTFBytes(len);		}						// TODO: Improve this by having some sort of key=type dictionary		private function parseProperties() : AWDProperties		{			var list_end : uint;			var list_len : uint;			var props : AWDProperties;						props = new AWDProperties();						list_len = _body.readUnsignedInt();			list_end = _body.position + list_len;			while (_body.position < list_end) {				var len : uint;				var key : uint;				var type : uint;								key = _body.readUnsignedShort();				len = _body.readUnsignedShort();				switch (key) {					case 1:						type = 6;						break;				}								props.set(key, parseAttrValue(type, len));			}						return props;		}				private function parseUserAttributes() : Object		{			var list_len : uint;						// TODO: Implement user attributes			list_len = _body.readUnsignedInt();			_body.position += list_len; // Skip for now						return null;		}				private function parseAttrValue(type : uint, len : uint) : *		{			var elem_len : uint;			var elem_count : uint;			var read_func : Function;						switch (type) {				case 1:					elem_len = 2;					read_func = _body.readShort;					break;				case 2:				case 6:					elem_len = 4;					read_func = _body.readUnsignedInt;					break;			}						if (elem_len < len) {				var list : Array;				var num_read : uint;				var num_elems : uint;								list = [];				num_read = 0;				num_elems = len / elem_len;				while (num_read < num_elems) {					list.push(read_func());					num_read++;				}								return list;			}			else {				var val : *;								val = read_func();				return val;			}		}	}}internal class AWDBlock{	public var id : uint;	public var data : *;}internal dynamic class AWDProperties{	public function set(key : uint, value : *) : void	{		this[key.toString()] = value;	}		public function get(key : uint, fallback : *) : *	{		if (this.hasOwnProperty(key.toString()))			return this[key.toString()];		else return fallback;	}}